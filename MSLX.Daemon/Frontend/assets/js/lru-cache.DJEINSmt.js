var Vt=Object.defineProperty;var Lt=c=>{throw TypeError(c)};var kt=(c,e,i)=>e in c?Vt(c,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[e]=i;var A=(c,e,i)=>kt(c,typeof e!="symbol"?e+"":e,i),Ot=(c,e,i)=>e.has(c)||Lt("Cannot "+i);var t=(c,e,i)=>(Ot(c,e,"read from private field"),i?i.call(c):e.get(c)),g=(c,e,i)=>e.has(c)?Lt("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(c):e.set(c,i),f=(c,e,i,s)=>(Ot(c,e,"write to private field"),s?s.call(c,i):e.set(c,i),i),l=(c,e,i)=>(Ot(c,e,"access private method"),i);var bt=(c,e,i,s)=>({set _(h){f(c,e,h,i)},get _(){return t(c,e,s)}});const Bt=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,jt=new Set,Et=typeof process=="object"&&process?process:{},Nt=(c,e,i,s)=>{typeof Et.emitWarning=="function"?Et.emitWarning(c,e,i,s):console.error(`[${i}] ${e}: ${c}`)};let Tt=globalThis.AbortController,xt=globalThis.AbortSignal;var Ut;if(typeof Tt>"u"){xt=class{constructor(){A(this,"onabort");A(this,"_onabort",[]);A(this,"reason");A(this,"aborted",!1)}addEventListener(s,h){this._onabort.push(h)}},Tt=class{constructor(){A(this,"signal",new xt);e()}abort(s){var h,n;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(n=(h=this.signal).onabort)==null||n.call(h,s)}}};let c=((Ut=Et.env)==null?void 0:Ut.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{c&&(c=!1,Nt("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const $t=c=>!jt.has(c),K=c=>c&&c===Math.floor(c)&&c>0&&isFinite(c),Pt=c=>K(c)?c<=Math.pow(2,8)?Uint8Array:c<=Math.pow(2,16)?Uint16Array:c<=Math.pow(2,32)?Uint32Array:c<=Number.MAX_SAFE_INTEGER?yt:null:null;class yt extends Array{constructor(e){super(e),this.fill(0)}}var ct;const st=class st{constructor(e,i){A(this,"heap");A(this,"length");if(!t(st,ct))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Pt(e);if(!i)return[];f(st,ct,!0);const s=new st(e,i);return f(st,ct,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};ct=new WeakMap,g(st,ct,!1);let zt=st;var Mt,Gt,N,L,P,nt,H,ut,dt,V,O,k,T,y,d,R,x,C,z,B,v,$,q,I,X,it,W,gt,o,vt,ht,Z,_t,U,Ht,rt,pt,mt,Q,tt,Ct,At,Ft,b,Rt,St,et,Wt;const Dt=class Dt{constructor(e){g(this,o);g(this,N);g(this,L);g(this,P);g(this,nt);g(this,H);g(this,ut);g(this,dt);g(this,V);A(this,"ttl");A(this,"ttlResolution");A(this,"ttlAutopurge");A(this,"updateAgeOnGet");A(this,"updateAgeOnHas");A(this,"allowStale");A(this,"noDisposeOnSet");A(this,"noUpdateTTL");A(this,"maxEntrySize");A(this,"sizeCalculation");A(this,"noDeleteOnFetchRejection");A(this,"noDeleteOnStaleGet");A(this,"allowStaleOnFetchAbort");A(this,"allowStaleOnFetchRejection");A(this,"ignoreFetchAbort");g(this,O);g(this,k);g(this,T);g(this,y);g(this,d);g(this,R);g(this,x);g(this,C);g(this,z);g(this,B);g(this,v);g(this,$);g(this,q);g(this,I);g(this,X);g(this,it);g(this,W);g(this,gt);g(this,ht,()=>{});g(this,Z,()=>{});g(this,_t,()=>{});g(this,U,()=>!1);g(this,rt,e=>{});g(this,pt,(e,i,s)=>{});g(this,mt,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});A(this,Mt,"LRUCache");const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:u,allowStale:a,dispose:m,onInsert:M,disposeAfter:_,noDisposeOnSet:J,noUpdateTTL:G,maxSize:Y=0,maxEntrySize:F=0,sizeCalculation:D,fetchMethod:p,memoMethod:E,noDeleteOnFetchRejection:w,noDeleteOnStaleGet:S,allowStaleOnFetchRejection:j,allowStaleOnFetchAbort:wt,ignoreFetchAbort:ot,perf:lt}=e;if(lt!==void 0&&typeof(lt==null?void 0:lt.now)!="function")throw new TypeError("perf option must have a now() method if specified");if(f(this,V,lt??Bt),i!==0&&!K(i))throw new TypeError("max option must be a nonnegative integer");const at=i?Pt(i):Array;if(!at)throw new Error("invalid max value: "+i);if(f(this,N,i),f(this,L,Y),this.maxEntrySize=F||t(this,L),this.sizeCalculation=D,this.sizeCalculation){if(!t(this,L)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(E!==void 0&&typeof E!="function")throw new TypeError("memoMethod must be a function if defined");if(f(this,dt,E),p!==void 0&&typeof p!="function")throw new TypeError("fetchMethod must be a function if specified");if(f(this,ut,p),f(this,it,!!p),f(this,T,new Map),f(this,y,new Array(i).fill(void 0)),f(this,d,new Array(i).fill(void 0)),f(this,R,new at(i)),f(this,x,new at(i)),f(this,C,0),f(this,z,0),f(this,B,zt.create(i)),f(this,O,0),f(this,k,0),typeof m=="function"&&f(this,P,m),typeof M=="function"&&f(this,nt,M),typeof _=="function"?(f(this,H,_),f(this,v,[])):(f(this,H,void 0),f(this,v,void 0)),f(this,X,!!t(this,P)),f(this,gt,!!t(this,nt)),f(this,W,!!t(this,H)),this.noDisposeOnSet=!!J,this.noUpdateTTL=!!G,this.noDeleteOnFetchRejection=!!w,this.allowStaleOnFetchRejection=!!j,this.allowStaleOnFetchAbort=!!wt,this.ignoreFetchAbort=!!ot,this.maxEntrySize!==0){if(t(this,L)!==0&&!K(t(this,L)))throw new TypeError("maxSize must be a positive integer if specified");if(!K(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");l(this,o,Ht).call(this)}if(this.allowStale=!!a,this.noDeleteOnStaleGet=!!S,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!u,this.ttlResolution=K(h)||h===0?h:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!K(this.ttl))throw new TypeError("ttl must be a positive integer if specified");l(this,o,vt).call(this)}if(t(this,N)===0&&this.ttl===0&&t(this,L)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,N)&&!t(this,L)){const ft="LRU_CACHE_UNBOUNDED";$t(ft)&&(jt.add(ft),Nt("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",ft,Dt))}}get perf(){return t(this,V)}static unsafeExposeInternals(e){return{starts:t(e,q),ttls:t(e,I),sizes:t(e,$),keyMap:t(e,T),keyList:t(e,y),valList:t(e,d),next:t(e,R),prev:t(e,x),get head(){return t(e,C)},get tail(){return t(e,z)},free:t(e,B),isBackgroundFetch:i=>{var s;return l(s=e,o,b).call(s,i)},backgroundFetch:(i,s,h,n)=>{var r;return l(r=e,o,Ft).call(r,i,s,h,n)},moveToTail:i=>{var s;return l(s=e,o,St).call(s,i)},indexes:i=>{var s;return l(s=e,o,Q).call(s,i)},rindexes:i=>{var s;return l(s=e,o,tt).call(s,i)},isStale:i=>{var s;return t(s=e,U).call(s,i)}}}get max(){return t(this,N)}get maxSize(){return t(this,L)}get calculatedSize(){return t(this,k)}get size(){return t(this,O)}get fetchMethod(){return t(this,ut)}get memoMethod(){return t(this,dt)}get dispose(){return t(this,P)}get onInsert(){return t(this,nt)}get disposeAfter(){return t(this,H)}getRemainingTTL(e){return t(this,T).has(e)?1/0:0}*entries(){for(const e of l(this,o,Q).call(this))t(this,d)[e]!==void 0&&t(this,y)[e]!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield[t(this,y)[e],t(this,d)[e]])}*rentries(){for(const e of l(this,o,tt).call(this))t(this,d)[e]!==void 0&&t(this,y)[e]!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield[t(this,y)[e],t(this,d)[e]])}*keys(){for(const e of l(this,o,Q).call(this)){const i=t(this,y)[e];i!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield i)}}*rkeys(){for(const e of l(this,o,tt).call(this)){const i=t(this,y)[e];i!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield i)}}*values(){for(const e of l(this,o,Q).call(this))t(this,d)[e]!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield t(this,d)[e])}*rvalues(){for(const e of l(this,o,tt).call(this))t(this,d)[e]!==void 0&&!l(this,o,b).call(this,t(this,d)[e])&&(yield t(this,d)[e])}[(Gt=Symbol.iterator,Mt=Symbol.toStringTag,Gt)](){return this.entries()}find(e,i={}){for(const s of l(this,o,Q).call(this)){const h=t(this,d)[s],n=l(this,o,b).call(this,h)?h.__staleWhileFetching:h;if(n!==void 0&&e(n,t(this,y)[s],this))return this.get(t(this,y)[s],i)}}forEach(e,i=this){for(const s of l(this,o,Q).call(this)){const h=t(this,d)[s],n=l(this,o,b).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,y)[s],this)}}rforEach(e,i=this){for(const s of l(this,o,tt).call(this)){const h=t(this,d)[s],n=l(this,o,b).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,y)[s],this)}}purgeStale(){let e=!1;for(const i of l(this,o,tt).call(this,{allowStale:!0}))t(this,U).call(this,i)&&(l(this,o,et).call(this,t(this,y)[i],"expire"),e=!0);return e}info(e){const i=t(this,T).get(e);if(i===void 0)return;const s=t(this,d)[i],h=l(this,o,b).call(this,s)?s.__staleWhileFetching:s;if(h===void 0)return;const n={value:h};if(t(this,I)&&t(this,q)){const r=t(this,I)[i],u=t(this,q)[i];if(r&&u){const a=r-(t(this,V).now()-u);n.ttl=a,n.start=Date.now()}}return t(this,$)&&(n.size=t(this,$)[i]),n}dump(){const e=[];for(const i of l(this,o,Q).call(this,{allowStale:!0})){const s=t(this,y)[i],h=t(this,d)[i],n=l(this,o,b).call(this,h)?h.__staleWhileFetching:h;if(n===void 0||s===void 0)continue;const r={value:n};if(t(this,I)&&t(this,q)){r.ttl=t(this,I)[i];const u=t(this,V).now()-t(this,q)[i];r.start=Math.floor(Date.now()-u)}t(this,$)&&(r.size=t(this,$)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=t(this,V).now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var J,G,Y,F,D,p,E;if(i===void 0)return this.delete(e),this;const{ttl:h=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:u=this.sizeCalculation,status:a}=s;let{noUpdateTTL:m=this.noUpdateTTL}=s;const M=t(this,mt).call(this,e,i,s.size||0,u);if(this.maxEntrySize&&M>this.maxEntrySize)return a&&(a.set="miss",a.maxEntrySizeExceeded=!0),l(this,o,et).call(this,e,"set"),this;let _=t(this,O)===0?void 0:t(this,T).get(e);if(_===void 0)_=t(this,O)===0?t(this,z):t(this,B).length!==0?t(this,B).pop():t(this,O)===t(this,N)?l(this,o,At).call(this,!1):t(this,O),t(this,y)[_]=e,t(this,d)[_]=i,t(this,T).set(e,_),t(this,R)[t(this,z)]=_,t(this,x)[_]=t(this,z),f(this,z,_),bt(this,O)._++,t(this,pt).call(this,_,M,a),a&&(a.set="add"),m=!1,t(this,gt)&&((J=t(this,nt))==null||J.call(this,i,e,"add"));else{l(this,o,St).call(this,_);const w=t(this,d)[_];if(i!==w){if(t(this,it)&&l(this,o,b).call(this,w)){w.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:S}=w;S!==void 0&&!r&&(t(this,X)&&((G=t(this,P))==null||G.call(this,S,e,"set")),t(this,W)&&((Y=t(this,v))==null||Y.push([S,e,"set"])))}else r||(t(this,X)&&((F=t(this,P))==null||F.call(this,w,e,"set")),t(this,W)&&((D=t(this,v))==null||D.push([w,e,"set"])));if(t(this,rt).call(this,_),t(this,pt).call(this,_,M,a),t(this,d)[_]=i,a){a.set="replace";const S=w&&l(this,o,b).call(this,w)?w.__staleWhileFetching:w;S!==void 0&&(a.oldValue=S)}}else a&&(a.set="update");t(this,gt)&&((p=this.onInsert)==null||p.call(this,i,e,i===w?"update":"replace"))}if(h!==0&&!t(this,I)&&l(this,o,vt).call(this),t(this,I)&&(m||t(this,_t).call(this,_,h,n),a&&t(this,Z).call(this,a,_)),!r&&t(this,W)&&t(this,v)){const w=t(this,v);let S;for(;S=w==null?void 0:w.shift();)(E=t(this,H))==null||E.call(this,...S)}return this}pop(){var e;try{for(;t(this,O);){const i=t(this,d)[t(this,C)];if(l(this,o,At).call(this,!0),l(this,o,b).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,v)){const i=t(this,v);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,H))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,n=t(this,T).get(e);if(n!==void 0){const r=t(this,d)[n];if(l(this,o,b).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,U).call(this,n))h&&(h.has="stale",t(this,Z).call(this,h,n));else return s&&t(this,ht).call(this,n),h&&(h.has="hit",t(this,Z).call(this,h,n)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,T).get(e);if(h===void 0||!s&&t(this,U).call(this,h))return;const n=t(this,d)[h];return l(this,o,b).call(this,n)?n.__staleWhileFetching:n}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:u=this.noDisposeOnSet,size:a=0,sizeCalculation:m=this.sizeCalculation,noUpdateTTL:M=this.noUpdateTTL,noDeleteOnFetchRejection:_=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:J=this.allowStaleOnFetchRejection,ignoreFetchAbort:G=this.ignoreFetchAbort,allowStaleOnFetchAbort:Y=this.allowStaleOnFetchAbort,context:F,forceRefresh:D=!1,status:p,signal:E}=i;if(!t(this,it))return p&&(p.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,status:p});const w={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:u,size:a,sizeCalculation:m,noUpdateTTL:M,noDeleteOnFetchRejection:_,allowStaleOnFetchRejection:J,allowStaleOnFetchAbort:Y,ignoreFetchAbort:G,status:p,signal:E};let S=t(this,T).get(e);if(S===void 0){p&&(p.fetch="miss");const j=l(this,o,Ft).call(this,e,S,w,F);return j.__returned=j}else{const j=t(this,d)[S];if(l(this,o,b).call(this,j)){const ft=s&&j.__staleWhileFetching!==void 0;return p&&(p.fetch="inflight",ft&&(p.returnedStale=!0)),ft?j.__staleWhileFetching:j.__returned=j}const wt=t(this,U).call(this,S);if(!D&&!wt)return p&&(p.fetch="hit"),l(this,o,St).call(this,S),h&&t(this,ht).call(this,S),p&&t(this,Z).call(this,p,S),j;const ot=l(this,o,Ft).call(this,e,S,w,F),at=ot.__staleWhileFetching!==void 0&&s;return p&&(p.fetch=wt?"stale":"refresh",at&&wt&&(p.returnedStale=!0)),at?ot.__staleWhileFetching:ot.__returned=ot}}async forceFetch(e,i={}){const s=await this.fetch(e,i);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(e,i={}){const s=t(this,dt);if(!s)throw new Error("no memoMethod provided to constructor");const{context:h,forceRefresh:n,...r}=i,u=this.get(e,r);if(!n&&u!==void 0)return u;const a=s(e,u,{options:r,context:h});return this.set(e,a,r),a}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=i,u=t(this,T).get(e);if(u!==void 0){const a=t(this,d)[u],m=l(this,o,b).call(this,a);return r&&t(this,Z).call(this,r,u),t(this,U).call(this,u)?(r&&(r.get="stale"),m?(r&&s&&a.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?a.__staleWhileFetching:void 0):(n||l(this,o,et).call(this,e,"expire"),r&&s&&(r.returnedStale=!0),s?a:void 0)):(r&&(r.get="hit"),m?a.__staleWhileFetching:(l(this,o,St).call(this,u),h&&t(this,ht).call(this,u),a))}else r&&(r.get="miss")}delete(e){return l(this,o,et).call(this,e,"delete")}clear(){return l(this,o,Wt).call(this,"delete")}};N=new WeakMap,L=new WeakMap,P=new WeakMap,nt=new WeakMap,H=new WeakMap,ut=new WeakMap,dt=new WeakMap,V=new WeakMap,O=new WeakMap,k=new WeakMap,T=new WeakMap,y=new WeakMap,d=new WeakMap,R=new WeakMap,x=new WeakMap,C=new WeakMap,z=new WeakMap,B=new WeakMap,v=new WeakMap,$=new WeakMap,q=new WeakMap,I=new WeakMap,X=new WeakMap,it=new WeakMap,W=new WeakMap,gt=new WeakMap,o=new WeakSet,vt=function(){const e=new yt(t(this,N)),i=new yt(t(this,N));f(this,I,e),f(this,q,i),f(this,_t,(n,r,u=t(this,V).now())=>{if(i[n]=r!==0?u:0,e[n]=r,r!==0&&this.ttlAutopurge){const a=setTimeout(()=>{t(this,U).call(this,n)&&l(this,o,et).call(this,t(this,y)[n],"expire")},r+1);a.unref&&a.unref()}}),f(this,ht,n=>{i[n]=e[n]!==0?t(this,V).now():0}),f(this,Z,(n,r)=>{if(e[r]){const u=e[r],a=i[r];if(!u||!a)return;n.ttl=u,n.start=a,n.now=s||h();const m=n.now-a;n.remainingTTL=u-m}});let s=0;const h=()=>{const n=t(this,V).now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=t(this,T).get(n);if(r===void 0)return 0;const u=e[r],a=i[r];if(!u||!a)return 1/0;const m=(s||h())-a;return u-m},f(this,U,n=>{const r=i[n],u=e[n];return!!u&&!!r&&(s||h())-r>u})},ht=new WeakMap,Z=new WeakMap,_t=new WeakMap,U=new WeakMap,Ht=function(){const e=new yt(t(this,N));f(this,k,0),f(this,$,e),f(this,rt,i=>{f(this,k,t(this,k)-e[i]),e[i]=0}),f(this,mt,(i,s,h,n)=>{if(l(this,o,b).call(this,s))return 0;if(!K(h))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(h=n(s,i),!K(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),f(this,pt,(i,s,h)=>{if(e[i]=s,t(this,L)){const n=t(this,L)-e[i];for(;t(this,k)>n;)l(this,o,At).call(this,!0)}f(this,k,t(this,k)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,k))})},rt=new WeakMap,pt=new WeakMap,mt=new WeakMap,Q=function*({allowStale:e=this.allowStale}={}){if(t(this,O))for(let i=t(this,z);!(!l(this,o,Ct).call(this,i)||((e||!t(this,U).call(this,i))&&(yield i),i===t(this,C)));)i=t(this,x)[i]},tt=function*({allowStale:e=this.allowStale}={}){if(t(this,O))for(let i=t(this,C);!(!l(this,o,Ct).call(this,i)||((e||!t(this,U).call(this,i))&&(yield i),i===t(this,z)));)i=t(this,R)[i]},Ct=function(e){return e!==void 0&&t(this,T).get(t(this,y)[e])===e},At=function(e){var n,r;const i=t(this,C),s=t(this,y)[i],h=t(this,d)[i];return t(this,it)&&l(this,o,b).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,X)||t(this,W))&&(t(this,X)&&((n=t(this,P))==null||n.call(this,h,s,"evict")),t(this,W)&&((r=t(this,v))==null||r.push([h,s,"evict"]))),t(this,rt).call(this,i),e&&(t(this,y)[i]=void 0,t(this,d)[i]=void 0,t(this,B).push(i)),t(this,O)===1?(f(this,C,f(this,z,0)),t(this,B).length=0):f(this,C,t(this,R)[i]),t(this,T).delete(s),bt(this,O)._--,i},Ft=function(e,i,s,h){const n=i===void 0?void 0:t(this,d)[i];if(l(this,o,b).call(this,n))return n;const r=new Tt,{signal:u}=s;u==null||u.addEventListener("abort",()=>r.abort(u.reason),{signal:r.signal});const a={signal:r.signal,options:s,context:h},m=(F,D=!1)=>{const{aborted:p}=r.signal,E=s.ignoreFetchAbort&&F!==void 0;if(s.status&&(p&&!D?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,E&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),p&&!E&&!D)return _(r.signal.reason);const w=G,S=t(this,d)[i];return(S===G||E&&D&&S===void 0)&&(F===void 0?w.__staleWhileFetching!==void 0?t(this,d)[i]=w.__staleWhileFetching:l(this,o,et).call(this,e,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(e,F,a.options))),F},M=F=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=F),_(F)),_=F=>{const{aborted:D}=r.signal,p=D&&s.allowStaleOnFetchAbort,E=p||s.allowStaleOnFetchRejection,w=E||s.noDeleteOnFetchRejection,S=G;if(t(this,d)[i]===G&&(!w||S.__staleWhileFetching===void 0?l(this,o,et).call(this,e,"fetch"):p||(t(this,d)[i]=S.__staleWhileFetching)),E)return s.status&&S.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),S.__staleWhileFetching;if(S.__returned===S)throw F},J=(F,D)=>{var E;const p=(E=t(this,ut))==null?void 0:E.call(this,e,n,a);p&&p instanceof Promise&&p.then(w=>F(w===void 0?void 0:w),D),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(F(void 0),s.allowStaleOnFetchAbort&&(F=w=>m(w,!0)))})};s.status&&(s.status.fetchDispatched=!0);const G=new Promise(J).then(m,M),Y=Object.assign(G,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return i===void 0?(this.set(e,Y,{...a.options,status:void 0}),i=t(this,T).get(e)):t(this,d)[i]=Y,Y},b=function(e){if(!t(this,it))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof Tt},Rt=function(e,i){t(this,x)[i]=e,t(this,R)[e]=i},St=function(e){e!==t(this,z)&&(e===t(this,C)?f(this,C,t(this,R)[e]):l(this,o,Rt).call(this,t(this,x)[e],t(this,R)[e]),l(this,o,Rt).call(this,t(this,z),e),f(this,z,e))},et=function(e,i){var h,n,r,u;let s=!1;if(t(this,O)!==0){const a=t(this,T).get(e);if(a!==void 0)if(s=!0,t(this,O)===1)l(this,o,Wt).call(this,i);else{t(this,rt).call(this,a);const m=t(this,d)[a];if(l(this,o,b).call(this,m)?m.__abortController.abort(new Error("deleted")):(t(this,X)||t(this,W))&&(t(this,X)&&((h=t(this,P))==null||h.call(this,m,e,i)),t(this,W)&&((n=t(this,v))==null||n.push([m,e,i]))),t(this,T).delete(e),t(this,y)[a]=void 0,t(this,d)[a]=void 0,a===t(this,z))f(this,z,t(this,x)[a]);else if(a===t(this,C))f(this,C,t(this,R)[a]);else{const M=t(this,x)[a];t(this,R)[M]=t(this,R)[a];const _=t(this,R)[a];t(this,x)[_]=t(this,x)[a]}bt(this,O)._--,t(this,B).push(a)}}if(t(this,W)&&((r=t(this,v))!=null&&r.length)){const a=t(this,v);let m;for(;m=a==null?void 0:a.shift();)(u=t(this,H))==null||u.call(this,...m)}return s},Wt=function(e){var i,s,h;for(const n of l(this,o,tt).call(this,{allowStale:!0})){const r=t(this,d)[n];if(l(this,o,b).call(this,r))r.__abortController.abort(new Error("deleted"));else{const u=t(this,y)[n];t(this,X)&&((i=t(this,P))==null||i.call(this,r,u,e)),t(this,W)&&((s=t(this,v))==null||s.push([r,u,e]))}}if(t(this,T).clear(),t(this,d).fill(void 0),t(this,y).fill(void 0),t(this,I)&&t(this,q)&&(t(this,I).fill(0),t(this,q).fill(0)),t(this,$)&&t(this,$).fill(0),f(this,C,0),f(this,z,0),t(this,B).length=0,f(this,k,0),f(this,O,0),t(this,W)&&t(this,v)){const n=t(this,v);let r;for(;r=n==null?void 0:n.shift();)(h=t(this,H))==null||h.call(this,...r)}};let It=Dt;export{It as L};
