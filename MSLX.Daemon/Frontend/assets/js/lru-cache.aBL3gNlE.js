var kt=Object.defineProperty;var It=u=>{throw TypeError(u)};var Bt=(u,e,i)=>e in u?kt(u,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):u[e]=i;var T=(u,e,i)=>Bt(u,typeof e!="symbol"?e+"":e,i),Et=(u,e,i)=>e.has(u)||It("Cannot "+i);var t=(u,e,i)=>(Et(u,e,"read from private field"),i?i.call(u):e.get(u)),g=(u,e,i)=>e.has(u)?It("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(u):e.set(u,i),f=(u,e,i,s)=>(Et(u,e,"write to private field"),s?s.call(u,i):e.set(u,i),i),l=(u,e,i)=>(Et(u,e,"access private method"),i);var yt=(u,e,i,s)=>({set _(h){f(u,e,h,i)},get _(){return t(u,e,s)}});const $t=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Nt=new Set,zt=typeof process=="object"&&process?process:{},Pt=(u,e,i,s)=>{typeof zt.emitWarning=="function"?zt.emitWarning(u,e,i,s):console.error(`[${i}] ${e}: ${u}`)};let Ot=globalThis.AbortController,xt=globalThis.AbortSignal;var Mt;if(typeof Ot>"u"){xt=class{constructor(){T(this,"onabort");T(this,"_onabort",[]);T(this,"reason");T(this,"aborted",!1)}addEventListener(s,h){this._onabort.push(h)}},Ot=class{constructor(){T(this,"signal",new xt);e()}abort(s){var h,o;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const n of this.signal._onabort)n(s);(o=(h=this.signal).onabort)==null||o.call(h,s)}}};let u=((Mt=zt.env)==null?void 0:Mt.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{u&&(u=!1,Pt("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const qt=u=>!Nt.has(u),Q=u=>u&&u===Math.floor(u)&&u>0&&isFinite(u),Ht=u=>Q(u)?u<=Math.pow(2,8)?Uint8Array:u<=Math.pow(2,16)?Uint16Array:u<=Math.pow(2,32)?Uint32Array:u<=Number.MAX_SAFE_INTEGER?At:null:null;class At extends Array{constructor(e){super(e),this.fill(0)}}var ut;const nt=class nt{constructor(e,i){T(this,"heap");T(this,"length");if(!t(nt,ut))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Ht(e);if(!i)return[];f(nt,ut,!0);const s=new nt(e,i);return f(nt,ut,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};ut=new WeakMap,g(nt,ut,!1);let vt=nt;var Gt,jt,P,x,H,ht,V,dt,gt,k,E,B,O,A,d,W,U,R,v,$,C,q,X,M,G,Y,st,D,pt,r,Ct,rt,K,_t,j,Vt,ot,wt,bt,tt,et,Rt,Tt,Ft,y,Wt,mt,it,Dt;const Lt=class Lt{constructor(e){g(this,r);g(this,P);g(this,x);g(this,H);g(this,ht);g(this,V);g(this,dt);g(this,gt);g(this,k);T(this,"ttl");T(this,"ttlResolution");T(this,"ttlAutopurge");T(this,"updateAgeOnGet");T(this,"updateAgeOnHas");T(this,"allowStale");T(this,"noDisposeOnSet");T(this,"noUpdateTTL");T(this,"maxEntrySize");T(this,"sizeCalculation");T(this,"noDeleteOnFetchRejection");T(this,"noDeleteOnStaleGet");T(this,"allowStaleOnFetchAbort");T(this,"allowStaleOnFetchRejection");T(this,"ignoreFetchAbort");g(this,E);g(this,B);g(this,O);g(this,A);g(this,d);g(this,W);g(this,U);g(this,R);g(this,v);g(this,$);g(this,C);g(this,q);g(this,X);g(this,M);g(this,G);g(this,Y);g(this,st);g(this,D);g(this,pt);g(this,rt,()=>{});g(this,K,()=>{});g(this,_t,()=>{});g(this,j,()=>!1);g(this,ot,e=>{});g(this,wt,(e,i,s)=>{});g(this,bt,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});T(this,Gt,"LRUCache");const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:o,updateAgeOnGet:n,updateAgeOnHas:a,allowStale:c,dispose:b,onInsert:p,disposeAfter:S,noDisposeOnSet:Z,noUpdateTTL:L,maxSize:J=0,maxEntrySize:F=0,sizeCalculation:I,fetchMethod:w,memoMethod:z,noDeleteOnFetchRejection:m,noDeleteOnStaleGet:_,allowStaleOnFetchRejection:N,allowStaleOnFetchAbort:St,ignoreFetchAbort:lt,perf:at}=e;if(at!==void 0&&typeof(at==null?void 0:at.now)!="function")throw new TypeError("perf option must have a now() method if specified");if(f(this,k,at??$t),i!==0&&!Q(i))throw new TypeError("max option must be a nonnegative integer");const ft=i?Ht(i):Array;if(!ft)throw new Error("invalid max value: "+i);if(f(this,P,i),f(this,x,J),this.maxEntrySize=F||t(this,x),this.sizeCalculation=I,this.sizeCalculation){if(!t(this,x)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(z!==void 0&&typeof z!="function")throw new TypeError("memoMethod must be a function if defined");if(f(this,gt,z),w!==void 0&&typeof w!="function")throw new TypeError("fetchMethod must be a function if specified");if(f(this,dt,w),f(this,st,!!w),f(this,O,new Map),f(this,A,new Array(i).fill(void 0)),f(this,d,new Array(i).fill(void 0)),f(this,W,new ft(i)),f(this,U,new ft(i)),f(this,R,0),f(this,v,0),f(this,$,vt.create(i)),f(this,E,0),f(this,B,0),typeof b=="function"&&f(this,H,b),typeof p=="function"&&f(this,ht,p),typeof S=="function"?(f(this,V,S),f(this,C,[])):(f(this,V,void 0),f(this,C,void 0)),f(this,Y,!!t(this,H)),f(this,pt,!!t(this,ht)),f(this,D,!!t(this,V)),this.noDisposeOnSet=!!Z,this.noUpdateTTL=!!L,this.noDeleteOnFetchRejection=!!m,this.allowStaleOnFetchRejection=!!N,this.allowStaleOnFetchAbort=!!St,this.ignoreFetchAbort=!!lt,this.maxEntrySize!==0){if(t(this,x)!==0&&!Q(t(this,x)))throw new TypeError("maxSize must be a positive integer if specified");if(!Q(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");l(this,r,Vt).call(this)}if(this.allowStale=!!c,this.noDeleteOnStaleGet=!!_,this.updateAgeOnGet=!!n,this.updateAgeOnHas=!!a,this.ttlResolution=Q(h)||h===0?h:1,this.ttlAutopurge=!!o,this.ttl=s||0,this.ttl){if(!Q(this.ttl))throw new TypeError("ttl must be a positive integer if specified");l(this,r,Ct).call(this)}if(t(this,P)===0&&this.ttl===0&&t(this,x)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,P)&&!t(this,x)){const ct="LRU_CACHE_UNBOUNDED";qt(ct)&&(Nt.add(ct),Pt("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",ct,Lt))}}get perf(){return t(this,k)}static unsafeExposeInternals(e){return{starts:t(e,X),ttls:t(e,M),autopurgeTimers:t(e,G),sizes:t(e,q),keyMap:t(e,O),keyList:t(e,A),valList:t(e,d),next:t(e,W),prev:t(e,U),get head(){return t(e,R)},get tail(){return t(e,v)},free:t(e,$),isBackgroundFetch:i=>{var s;return l(s=e,r,y).call(s,i)},backgroundFetch:(i,s,h,o)=>{var n;return l(n=e,r,Ft).call(n,i,s,h,o)},moveToTail:i=>{var s;return l(s=e,r,mt).call(s,i)},indexes:i=>{var s;return l(s=e,r,tt).call(s,i)},rindexes:i=>{var s;return l(s=e,r,et).call(s,i)},isStale:i=>{var s;return t(s=e,j).call(s,i)}}}get max(){return t(this,P)}get maxSize(){return t(this,x)}get calculatedSize(){return t(this,B)}get size(){return t(this,E)}get fetchMethod(){return t(this,dt)}get memoMethod(){return t(this,gt)}get dispose(){return t(this,H)}get onInsert(){return t(this,ht)}get disposeAfter(){return t(this,V)}getRemainingTTL(e){return t(this,O).has(e)?1/0:0}*entries(){for(const e of l(this,r,tt).call(this))t(this,d)[e]!==void 0&&t(this,A)[e]!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield[t(this,A)[e],t(this,d)[e]])}*rentries(){for(const e of l(this,r,et).call(this))t(this,d)[e]!==void 0&&t(this,A)[e]!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield[t(this,A)[e],t(this,d)[e]])}*keys(){for(const e of l(this,r,tt).call(this)){const i=t(this,A)[e];i!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield i)}}*rkeys(){for(const e of l(this,r,et).call(this)){const i=t(this,A)[e];i!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield i)}}*values(){for(const e of l(this,r,tt).call(this))t(this,d)[e]!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield t(this,d)[e])}*rvalues(){for(const e of l(this,r,et).call(this))t(this,d)[e]!==void 0&&!l(this,r,y).call(this,t(this,d)[e])&&(yield t(this,d)[e])}[(jt=Symbol.iterator,Gt=Symbol.toStringTag,jt)](){return this.entries()}find(e,i={}){for(const s of l(this,r,tt).call(this)){const h=t(this,d)[s],o=l(this,r,y).call(this,h)?h.__staleWhileFetching:h;if(o!==void 0&&e(o,t(this,A)[s],this))return this.get(t(this,A)[s],i)}}forEach(e,i=this){for(const s of l(this,r,tt).call(this)){const h=t(this,d)[s],o=l(this,r,y).call(this,h)?h.__staleWhileFetching:h;o!==void 0&&e.call(i,o,t(this,A)[s],this)}}rforEach(e,i=this){for(const s of l(this,r,et).call(this)){const h=t(this,d)[s],o=l(this,r,y).call(this,h)?h.__staleWhileFetching:h;o!==void 0&&e.call(i,o,t(this,A)[s],this)}}purgeStale(){let e=!1;for(const i of l(this,r,et).call(this,{allowStale:!0}))t(this,j).call(this,i)&&(l(this,r,it).call(this,t(this,A)[i],"expire"),e=!0);return e}info(e){const i=t(this,O).get(e);if(i===void 0)return;const s=t(this,d)[i],h=l(this,r,y).call(this,s)?s.__staleWhileFetching:s;if(h===void 0)return;const o={value:h};if(t(this,M)&&t(this,X)){const n=t(this,M)[i],a=t(this,X)[i];if(n&&a){const c=n-(t(this,k).now()-a);o.ttl=c,o.start=Date.now()}}return t(this,q)&&(o.size=t(this,q)[i]),o}dump(){const e=[];for(const i of l(this,r,tt).call(this,{allowStale:!0})){const s=t(this,A)[i],h=t(this,d)[i],o=l(this,r,y).call(this,h)?h.__staleWhileFetching:h;if(o===void 0||s===void 0)continue;const n={value:o};if(t(this,M)&&t(this,X)){n.ttl=t(this,M)[i];const a=t(this,k).now()-t(this,X)[i];n.start=Math.floor(Date.now()-a)}t(this,q)&&(n.size=t(this,q)[i]),e.unshift([s,n])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=t(this,k).now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var Z,L,J,F,I,w,z;if(i===void 0)return this.delete(e),this;const{ttl:h=this.ttl,start:o,noDisposeOnSet:n=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:c}=s;let{noUpdateTTL:b=this.noUpdateTTL}=s;const p=t(this,bt).call(this,e,i,s.size||0,a);if(this.maxEntrySize&&p>this.maxEntrySize)return c&&(c.set="miss",c.maxEntrySizeExceeded=!0),l(this,r,it).call(this,e,"set"),this;let S=t(this,E)===0?void 0:t(this,O).get(e);if(S===void 0)S=t(this,E)===0?t(this,v):t(this,$).length!==0?t(this,$).pop():t(this,E)===t(this,P)?l(this,r,Tt).call(this,!1):t(this,E),t(this,A)[S]=e,t(this,d)[S]=i,t(this,O).set(e,S),t(this,W)[t(this,v)]=S,t(this,U)[S]=t(this,v),f(this,v,S),yt(this,E)._++,t(this,wt).call(this,S,p,c),c&&(c.set="add"),b=!1,t(this,pt)&&((Z=t(this,ht))==null||Z.call(this,i,e,"add"));else{l(this,r,mt).call(this,S);const m=t(this,d)[S];if(i!==m){if(t(this,st)&&l(this,r,y).call(this,m)){m.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:_}=m;_!==void 0&&!n&&(t(this,Y)&&((L=t(this,H))==null||L.call(this,_,e,"set")),t(this,D)&&((J=t(this,C))==null||J.push([_,e,"set"])))}else n||(t(this,Y)&&((F=t(this,H))==null||F.call(this,m,e,"set")),t(this,D)&&((I=t(this,C))==null||I.push([m,e,"set"])));if(t(this,ot).call(this,S),t(this,wt).call(this,S,p,c),t(this,d)[S]=i,c){c.set="replace";const _=m&&l(this,r,y).call(this,m)?m.__staleWhileFetching:m;_!==void 0&&(c.oldValue=_)}}else c&&(c.set="update");t(this,pt)&&((w=this.onInsert)==null||w.call(this,i,e,i===m?"update":"replace"))}if(h!==0&&!t(this,M)&&l(this,r,Ct).call(this),t(this,M)&&(b||t(this,_t).call(this,S,h,o),c&&t(this,K).call(this,c,S)),!n&&t(this,D)&&t(this,C)){const m=t(this,C);let _;for(;_=m==null?void 0:m.shift();)(z=t(this,V))==null||z.call(this,..._)}return this}pop(){var e;try{for(;t(this,E);){const i=t(this,d)[t(this,R)];if(l(this,r,Tt).call(this,!0),l(this,r,y).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,D)&&t(this,C)){const i=t(this,C);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,V))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,o=t(this,O).get(e);if(o!==void 0){const n=t(this,d)[o];if(l(this,r,y).call(this,n)&&n.__staleWhileFetching===void 0)return!1;if(t(this,j).call(this,o))h&&(h.has="stale",t(this,K).call(this,h,o));else return s&&t(this,rt).call(this,o),h&&(h.has="hit",t(this,K).call(this,h,o)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,O).get(e);if(h===void 0||!s&&t(this,j).call(this,h))return;const o=t(this,d)[h];return l(this,r,y).call(this,o)?o.__staleWhileFetching:o}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:n=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:c=0,sizeCalculation:b=this.sizeCalculation,noUpdateTTL:p=this.noUpdateTTL,noDeleteOnFetchRejection:S=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:Z=this.allowStaleOnFetchRejection,ignoreFetchAbort:L=this.ignoreFetchAbort,allowStaleOnFetchAbort:J=this.allowStaleOnFetchAbort,context:F,forceRefresh:I=!1,status:w,signal:z}=i;if(!t(this,st))return w&&(w.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:o,status:w});const m={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:o,ttl:n,noDisposeOnSet:a,size:c,sizeCalculation:b,noUpdateTTL:p,noDeleteOnFetchRejection:S,allowStaleOnFetchRejection:Z,allowStaleOnFetchAbort:J,ignoreFetchAbort:L,status:w,signal:z};let _=t(this,O).get(e);if(_===void 0){w&&(w.fetch="miss");const N=l(this,r,Ft).call(this,e,_,m,F);return N.__returned=N}else{const N=t(this,d)[_];if(l(this,r,y).call(this,N)){const ct=s&&N.__staleWhileFetching!==void 0;return w&&(w.fetch="inflight",ct&&(w.returnedStale=!0)),ct?N.__staleWhileFetching:N.__returned=N}const St=t(this,j).call(this,_);if(!I&&!St)return w&&(w.fetch="hit"),l(this,r,mt).call(this,_),h&&t(this,rt).call(this,_),w&&t(this,K).call(this,w,_),N;const lt=l(this,r,Ft).call(this,e,_,m,F),ft=lt.__staleWhileFetching!==void 0&&s;return w&&(w.fetch=St?"stale":"refresh",ft&&St&&(w.returnedStale=!0)),ft?lt.__staleWhileFetching:lt.__returned=lt}}async forceFetch(e,i={}){const s=await this.fetch(e,i);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(e,i={}){const s=t(this,gt);if(!s)throw new Error("no memoMethod provided to constructor");const{context:h,forceRefresh:o,...n}=i,a=this.get(e,n);if(!o&&a!==void 0)return a;const c=s(e,a,{options:n,context:h});return this.set(e,c,n),c}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:n}=i,a=t(this,O).get(e);if(a!==void 0){const c=t(this,d)[a],b=l(this,r,y).call(this,c);return n&&t(this,K).call(this,n,a),t(this,j).call(this,a)?(n&&(n.get="stale"),b?(n&&s&&c.__staleWhileFetching!==void 0&&(n.returnedStale=!0),s?c.__staleWhileFetching:void 0):(o||l(this,r,it).call(this,e,"expire"),n&&s&&(n.returnedStale=!0),s?c:void 0)):(n&&(n.get="hit"),b?c.__staleWhileFetching:(l(this,r,mt).call(this,a),h&&t(this,rt).call(this,a),c))}else n&&(n.get="miss")}delete(e){return l(this,r,it).call(this,e,"delete")}clear(){return l(this,r,Dt).call(this,"delete")}};P=new WeakMap,x=new WeakMap,H=new WeakMap,ht=new WeakMap,V=new WeakMap,dt=new WeakMap,gt=new WeakMap,k=new WeakMap,E=new WeakMap,B=new WeakMap,O=new WeakMap,A=new WeakMap,d=new WeakMap,W=new WeakMap,U=new WeakMap,R=new WeakMap,v=new WeakMap,$=new WeakMap,C=new WeakMap,q=new WeakMap,X=new WeakMap,M=new WeakMap,G=new WeakMap,Y=new WeakMap,st=new WeakMap,D=new WeakMap,pt=new WeakMap,r=new WeakSet,Ct=function(){const e=new At(t(this,P)),i=new At(t(this,P));f(this,M,e),f(this,X,i);const s=this.ttlAutopurge?new Array(t(this,P)):void 0;f(this,G,s),f(this,_t,(n,a,c=t(this,k).now())=>{if(i[n]=a!==0?c:0,e[n]=a,s!=null&&s[n]&&(clearTimeout(s[n]),s[n]=void 0),a!==0&&s){const b=setTimeout(()=>{t(this,j).call(this,n)&&l(this,r,it).call(this,t(this,A)[n],"expire")},a+1);b.unref&&b.unref(),s[n]=b}}),f(this,rt,n=>{i[n]=e[n]!==0?t(this,k).now():0}),f(this,K,(n,a)=>{if(e[a]){const c=e[a],b=i[a];if(!c||!b)return;n.ttl=c,n.start=b,n.now=h||o();const p=n.now-b;n.remainingTTL=c-p}});let h=0;const o=()=>{const n=t(this,k).now();if(this.ttlResolution>0){h=n;const a=setTimeout(()=>h=0,this.ttlResolution);a.unref&&a.unref()}return n};this.getRemainingTTL=n=>{const a=t(this,O).get(n);if(a===void 0)return 0;const c=e[a],b=i[a];if(!c||!b)return 1/0;const p=(h||o())-b;return c-p},f(this,j,n=>{const a=i[n],c=e[n];return!!c&&!!a&&(h||o())-a>c})},rt=new WeakMap,K=new WeakMap,_t=new WeakMap,j=new WeakMap,Vt=function(){const e=new At(t(this,P));f(this,B,0),f(this,q,e),f(this,ot,i=>{f(this,B,t(this,B)-e[i]),e[i]=0}),f(this,bt,(i,s,h,o)=>{if(l(this,r,y).call(this,s))return 0;if(!Q(h))if(o){if(typeof o!="function")throw new TypeError("sizeCalculation must be a function");if(h=o(s,i),!Q(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),f(this,wt,(i,s,h)=>{if(e[i]=s,t(this,x)){const o=t(this,x)-e[i];for(;t(this,B)>o;)l(this,r,Tt).call(this,!0)}f(this,B,t(this,B)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,B))})},ot=new WeakMap,wt=new WeakMap,bt=new WeakMap,tt=function*({allowStale:e=this.allowStale}={}){if(t(this,E))for(let i=t(this,v);!(!l(this,r,Rt).call(this,i)||((e||!t(this,j).call(this,i))&&(yield i),i===t(this,R)));)i=t(this,U)[i]},et=function*({allowStale:e=this.allowStale}={}){if(t(this,E))for(let i=t(this,R);!(!l(this,r,Rt).call(this,i)||((e||!t(this,j).call(this,i))&&(yield i),i===t(this,v)));)i=t(this,W)[i]},Rt=function(e){return e!==void 0&&t(this,O).get(t(this,A)[e])===e},Tt=function(e){var o,n,a;const i=t(this,R),s=t(this,A)[i],h=t(this,d)[i];return t(this,st)&&l(this,r,y).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,Y)||t(this,D))&&(t(this,Y)&&((o=t(this,H))==null||o.call(this,h,s,"evict")),t(this,D)&&((n=t(this,C))==null||n.push([h,s,"evict"]))),t(this,ot).call(this,i),(a=t(this,G))!=null&&a[i]&&(clearTimeout(t(this,G)[i]),t(this,G)[i]=void 0),e&&(t(this,A)[i]=void 0,t(this,d)[i]=void 0,t(this,$).push(i)),t(this,E)===1?(f(this,R,f(this,v,0)),t(this,$).length=0):f(this,R,t(this,W)[i]),t(this,O).delete(s),yt(this,E)._--,i},Ft=function(e,i,s,h){const o=i===void 0?void 0:t(this,d)[i];if(l(this,r,y).call(this,o))return o;const n=new Ot,{signal:a}=s;a==null||a.addEventListener("abort",()=>n.abort(a.reason),{signal:n.signal});const c={signal:n.signal,options:s,context:h},b=(F,I=!1)=>{const{aborted:w}=n.signal,z=s.ignoreFetchAbort&&F!==void 0;if(s.status&&(w&&!I?(s.status.fetchAborted=!0,s.status.fetchError=n.signal.reason,z&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),w&&!z&&!I)return S(n.signal.reason);const m=L,_=t(this,d)[i];return(_===L||z&&I&&_===void 0)&&(F===void 0?m.__staleWhileFetching!==void 0?t(this,d)[i]=m.__staleWhileFetching:l(this,r,it).call(this,e,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(e,F,c.options))),F},p=F=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=F),S(F)),S=F=>{const{aborted:I}=n.signal,w=I&&s.allowStaleOnFetchAbort,z=w||s.allowStaleOnFetchRejection,m=z||s.noDeleteOnFetchRejection,_=L;if(t(this,d)[i]===L&&(!m||_.__staleWhileFetching===void 0?l(this,r,it).call(this,e,"fetch"):w||(t(this,d)[i]=_.__staleWhileFetching)),z)return s.status&&_.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),_.__staleWhileFetching;if(_.__returned===_)throw F},Z=(F,I)=>{var z;const w=(z=t(this,dt))==null?void 0:z.call(this,e,o,c);w&&w instanceof Promise&&w.then(m=>F(m===void 0?void 0:m),I),n.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(F(void 0),s.allowStaleOnFetchAbort&&(F=m=>b(m,!0)))})};s.status&&(s.status.fetchDispatched=!0);const L=new Promise(Z).then(b,p),J=Object.assign(L,{__abortController:n,__staleWhileFetching:o,__returned:void 0});return i===void 0?(this.set(e,J,{...c.options,status:void 0}),i=t(this,O).get(e)):t(this,d)[i]=J,J},y=function(e){if(!t(this,st))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof Ot},Wt=function(e,i){t(this,U)[i]=e,t(this,W)[e]=i},mt=function(e){e!==t(this,v)&&(e===t(this,R)?f(this,R,t(this,W)[e]):l(this,r,Wt).call(this,t(this,U)[e],t(this,W)[e]),l(this,r,Wt).call(this,t(this,v),e),f(this,v,e))},it=function(e,i){var h,o,n,a,c,b;let s=!1;if(t(this,E)!==0){const p=t(this,O).get(e);if(p!==void 0)if((h=t(this,G))!=null&&h[p]&&(clearTimeout((o=t(this,G))==null?void 0:o[p]),t(this,G)[p]=void 0),s=!0,t(this,E)===1)l(this,r,Dt).call(this,i);else{t(this,ot).call(this,p);const S=t(this,d)[p];if(l(this,r,y).call(this,S)?S.__abortController.abort(new Error("deleted")):(t(this,Y)||t(this,D))&&(t(this,Y)&&((n=t(this,H))==null||n.call(this,S,e,i)),t(this,D)&&((a=t(this,C))==null||a.push([S,e,i]))),t(this,O).delete(e),t(this,A)[p]=void 0,t(this,d)[p]=void 0,p===t(this,v))f(this,v,t(this,U)[p]);else if(p===t(this,R))f(this,R,t(this,W)[p]);else{const Z=t(this,U)[p];t(this,W)[Z]=t(this,W)[p];const L=t(this,W)[p];t(this,U)[L]=t(this,U)[p]}yt(this,E)._--,t(this,$).push(p)}}if(t(this,D)&&((c=t(this,C))!=null&&c.length)){const p=t(this,C);let S;for(;S=p==null?void 0:p.shift();)(b=t(this,V))==null||b.call(this,...S)}return s},Dt=function(e){var i,s,h,o;for(const n of l(this,r,et).call(this,{allowStale:!0})){const a=t(this,d)[n];if(l(this,r,y).call(this,a))a.__abortController.abort(new Error("deleted"));else{const c=t(this,A)[n];t(this,Y)&&((i=t(this,H))==null||i.call(this,a,c,e)),t(this,D)&&((s=t(this,C))==null||s.push([a,c,e]))}}if(t(this,O).clear(),t(this,d).fill(void 0),t(this,A).fill(void 0),t(this,M)&&t(this,X)){t(this,M).fill(0),t(this,X).fill(0);for(const n of t(this,G)??[])n!==void 0&&clearTimeout(n);(h=t(this,G))==null||h.fill(void 0)}if(t(this,q)&&t(this,q).fill(0),f(this,R,0),f(this,v,0),t(this,$).length=0,f(this,B,0),f(this,E,0),t(this,D)&&t(this,C)){const n=t(this,C);let a;for(;a=n==null?void 0:n.shift();)(o=t(this,V))==null||o.call(this,...a)}};let Ut=Lt;export{Ut as L};
